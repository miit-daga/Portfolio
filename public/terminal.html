<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Miit Daga - Terminal</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            background-color: #000;
            color: #0F0;
            font-family: 'Roboto Mono', monospace;
            overflow: hidden;
        }
        #matrix-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: -1;
            opacity: 0.3;
        }
        #terminal {
            width: 100%;
            height: 100vh;
            padding: 1.5rem;
            overflow-y: auto;
            scrollbar-width: none; /* Firefox */
        }
        #terminal::-webkit-scrollbar {
            display: none; /* Safari and Chrome */
        }
        .prompt::before {
            content: 'intruder@miit-daga:~$ \00a0';
            color: #0F0;
            font-weight: 700;
        }
        .output {
            white-space: pre-wrap;
        }
        .input-container {
            position: relative;
            flex-grow: 1;
            height: 1.5em; 
        }
        #input-line {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            caret-color: #0F0;
            background: transparent;
            border: none;
            outline: none;
            color: #0F0;
            font-family: 'Roboto Mono', monospace;
            z-index: 10;
        }
        #ghost-input {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: transparent;
            border: none;
            outline: none;
            color: rgba(0, 255, 0, 0.3);
            font-family: 'Roboto Mono', monospace;
            z-index: 5;
            pointer-events: none; 
        }
        .nav-link {
            color: #0ff;
            text-decoration: underline;
            cursor: pointer;
        }
        .nav-link:hover {
            background-color: #0ff;
            color: #000;
        }
        .section-title {
            color: #0ff;
            font-weight: 700;
            text-transform: uppercase;
            margin-top: 1rem;
            margin-bottom: 0.5rem;
        }
        .ascii-art {
            white-space: pre;
            font-weight: 700;
            margin-bottom: 1rem;
            line-height: 1.2;
            color: #0F0;
        }
        .error-text { color: #ff3333; }
        .highlight-name { color: #fff; font-weight: 700; }
        .highlight-date { color: #888; }
        .highlight-dim { color: #6a6; }
        .highlight-value { color: #0ff; }
        .help-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.25rem 2rem;
            margin-top: 0.5rem;
        }
        .help-category {
            color: #888;
            font-weight: 700;
            text-transform: uppercase;
            font-size: 0.8em;
            margin-top: 0.75rem;
            margin-bottom: 0.25rem;
            letter-spacing: 0.1em;
        }
        /* Overlay Style */
        #start-overlay {
            position: fixed;
            inset: 0;
            background: black;
            z-index: 9999;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }
        .blink {
            animation: blinker 1s linear infinite;
        }
        @keyframes blinker {
            50% { opacity: 0; }
        }
    </style>
</head>
<body class="bg-black text-green-400">

    <!-- CLICK TO START OVERLAY -->
    <div id="start-overlay">
        <div class="text-xl md:text-2xl font-bold blink border border-green-500 p-4 rounded bg-green-900/20">
            > CLICK TO INITIALIZE SYSTEM <
        </div>
    </div>

    <canvas id="matrix-canvas"></canvas>

    <div id="terminal" onclick="document.getElementById('input-line').focus()">
        <div id="output-container"></div>
        <div class="flex items-center">
            <span class="prompt"></span>
            <div class="input-container">
                <input type="text" id="ghost-input" disabled>
                <input type="text" id="input-line" class="bg-transparent border-none outline-none text-green-400 flex-grow" autofocus autocomplete="off" spellcheck="false">
            </div>
        </div>
    </div>

    <script type="module">
        // --- SOUND ENGINE ---
        const SoundFX = {
            ctx: null,
            isMuted: false,
            
            init: function() {
                if (!this.ctx) {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    this.ctx = new AudioContext();
                } else if (this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
            },

            playTone: function(freq, type, duration, vol = 0.1) {
                if (this.isMuted || !this.ctx || this.ctx.state !== 'running') return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                osc.frequency.value = freq;
                osc.type = type;
                
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                
                const now = this.ctx.currentTime;
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(vol, now + 0.01);
                gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
                
                osc.start(now);
                osc.stop(now + duration);
            },

            // --- USER TYPING SOUNDS ---
            typing: function(key) {
                if (this.isMuted) return;

                let freq = 800;
                let type = 'square';
                let duration = 0.06;
                let vol = 0.05;

                if (key >= '0' && key <= '9') {
                    const num = parseInt(key);
                    freq = 1000 + (num * 100); 
                    type = 'sine'; 
                    duration = 0.08;
                    vol = 0.08;
                }
                else if (key.length === 1 && key.match(/[a-z]/i)) {
                    const code = key.toLowerCase().charCodeAt(0) - 97; 
                    freq = 200 + (code * 15);
                    type = 'square'; 
                }
                else if (key === ' ') {
                    freq = 120;
                    type = 'sawtooth';
                    duration = 0.05;
                    vol = 0.08;
                }
                else if (key === 'Backspace') {
                    freq = 100;
                    type = 'sawtooth';
                    duration = 0.08;
                }
                else {
                    freq = 800;
                    type = 'triangle';
                }

                this.playTone(freq, type, duration, vol);
            },

            // --- SYSTEM SOUNDS ---
            startup: function() {
                if (this.isMuted || !this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sine';
                osc.connect(gain);
                gain.connect(this.ctx.destination);

                const now = this.ctx.currentTime;
                osc.frequency.setValueAtTime(100, now);
                osc.frequency.exponentialRampToValueAtTime(1000, now + 2);
                
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(0.1, now + 1);
                gain.gain.linearRampToValueAtTime(0, now + 2);

                osc.start(now);
                osc.stop(now + 2);
            },

            dataBurst: function() {
                if (this.isMuted || !this.ctx) return;
                const count = 15;
                for(let i=0; i<count; i++) {
                    setTimeout(() => {
                        this.playTone(400 + Math.random() * 800, 'square', 0.05, 0.03);
                    }, i * 30);
                }
            },

            compute: function() {
                if (this.isMuted || !this.ctx) return;
                this.playTone(200 + Math.random() * 50, 'sawtooth', 0.1, 0.05);
            },

            deleteProcess: function() {
                // Low crunching/processing sound
                if (this.isMuted || !this.ctx) return;
                const count = 6;
                for(let i=0; i<count; i++) {
                    setTimeout(() => {
                        this.playTone(100, 'square', 0.05, 0.05);
                    }, i * 150);
                }
            },

            funny: function() {
                // A "slide whistle" / clown sound
                if (this.isMuted || !this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                
                osc.type = 'triangle';
                const now = this.ctx.currentTime;
                
                // Slide up then down
                osc.frequency.setValueAtTime(400, now);
                osc.frequency.linearRampToValueAtTime(600, now + 0.1);
                osc.frequency.linearRampToValueAtTime(300, now + 0.4);

                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.4);

                osc.start(now);
                osc.stop(now + 0.4);
            },

            successChime: function() {
                if (this.isMuted || !this.ctx) return;
                [440, 554, 659].forEach((freq, i) => { 
                    setTimeout(() => {
                        this.playTone(freq, 'sine', 0.6, 0.05);
                    }, i * 100);
                });
            },

            enter: function() {
                if (this.isMuted || !this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.frequency.setValueAtTime(600, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(1200, this.ctx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.05, this.ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.1);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.1);
            },

            error: function() {
                this.playTone(150, 'sawtooth', 0.2, 0.1);
            },

            meow: function() {
                if (this.isMuted) return;
                const audio = new Audio('meow.mp3'); 
                audio.volume = 0.5;
                audio.play().catch(e => console.log("Missing meow.mp3"));
            },
            
            glitch: function() {
                if (this.isMuted || !this.ctx) return;
                const count = 10;
                for(let i=0; i<count; i++) {
                    setTimeout(() => {
                        this.playTone(Math.random() * 1000, 'sawtooth', 0.05, 0.05);
                    }, i * 30);
                }
            },

            powerDown: function() {
                if (this.isMuted || !this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sawtooth';
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.frequency.setValueAtTime(400, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(50, this.ctx.currentTime + 1);
                gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 1);
                osc.start();
                osc.stop(this.ctx.currentTime + 1);
            }
        };

        // --- DATA ---
        const MOCK_DATA = {
          name: "Miit Daga",
          email: "miitcodes27@gmail.com",
          socials: [
            { name: 'GitHub', url: 'https://github.com/miit-daga' },
            { name: 'LinkedIn', url: 'https://www.linkedin.com/in/miit-daga' },
          ],
          resumeUrl: "https://drive.google.com/file/d/1kiqfQF5cPjSXrU6ZgsC0t2XLkKZ2wkYO/view?usp=sharing",
          about: "As a final year B.Tech student in Information Technology at Vellore Institute of Technology, I have a deep passion for backend development and a strong interest in AI and ML. Currently diving into Deep Learning, I eagerly explore new ideas and expand my expertise. Fluent in English, Hindi, Gujarati, and Bengali, engaging with diverse communities and embracing challenges comes naturally. A quick learner and team player, contributing, collaborating, and growing alongside peers is always a priority. Actively seeking opportunities to work on projects that enhance my skills and create a meaningful impact.",
          experience: [
            { company: "Akatsuki AI Technologies", role: "Full Stack Engineering Intern ‚Äî Remote", date: "Oct 2025 ‚Äì Present", points: ["Selected for the CAIO Technical Unit, supporting technical research and system design under the CAIO's supervision.", "Leading a team and coordinating development efforts alongside senior engineers.", "Driving end-to-end feature development and aligning technical decisions across internal initiatives.", "Improving system reliability, contributing to architectural discussions, and supporting internal project management."] },
            { company: "Tata Power", role: "Project Intern ‚Äî Mumbai, India", date: "May 2025 ‚Äì Jul 2025", points: ["Optimized blower pipeline for 80+ Maithon units, cutting processing time from 6 minutes to 30 seconds for real-time updates.", "Resolved critical UTC‚ÄìIST bug in Maithon dashboards, ensuring data accuracy; also cut key API response time from ~35s to ‚â§5s.", "Built real-time data aggregator and API for PPGCL plant, ensuring 99.9% scheduler reliability and live tracking of 60+ parameters.", "Merged 2 legacy codebases for Jojobera plant into a unified async system, enhancing scalability & reducing response time by 40%."] },
            { company: "TechWire Studio", role: "Full Stack Developer Intern ‚Äî Remote", date: "Mar 2025 ‚Äì Jun 2025", points: ["Developed backend for Xceed Electronics with inventory tracking, Waldom API, and payments; supports 1000+ monthly actions.", "Improved backend API performance by 40%, optimizing workflows and deploying on AWS for reliable scaling.", "Created backend for a headless SaaS inventory platform with async S3 image uploads, cutting update times by 90%.", "Implemented a secure dual-role auth with Firebase JWT, enabling role-based access for admins and clients."] },
            { company: "Seculinx", role: "Backend Intern ‚Äî Vellore, India", date: "Sep 2024 ‚Äì Jan 2025", points: ["Developed the company's website backend from the ground up, designing the database schema and implementing REST APIs.", "Managed the complete deployment on AWS, ensuring high availability (~ 99.9% uptime) and consistent performance."] }
          ],
          education: [
            { institution: "Vellore Institute of Technology", degree: "B.Tech, Information Technology", date: "2022 ‚Äì Present", note: "CGPA:9.20 / 10" },
            { institution: "Swami Vivekananda Vidyamandir", degree: "Higher Secondary Education (Class XII)", date: "2020 ‚Äì 2022", note: "Percentage: 92%" },
            { institution: "St. Helen's School", degree: "Primary & Secondary Education (Class X)", date: "Apr 2008 ‚Äì Jul 2020", note: "Percentage: 91.6%" },
          ],
          skills: {
            "Languages": ["JavaScript", "TypeScript", "Java", "Python", "C", "C++", "HTML", "CSS", "SQL"],
            "Libraries/Frameworks": ["NodeJS", "ExpressJS", "ReactJS", "NextJS", "Bootstrap", "Chakra UI"],
            "Databases": ["MongoDB", "MySQL", "PostgreSQL", "Redis", "Firebase"],
            "Other Tools & Platforms": ["Git", "Postman", "AWS", "Nginx", "VS Code", "Render", "Vercel", "Netlify"],
          },
          achievements: [
            { title: "2nd Place | Synapse Hackathon (Yantra-2025)", description: "Backend for automated MoCA cognitive test." },
            { title: "2nd Place | Hackovation Hackathon (GraVITas-2024)", description: "Backend for high-volume emergency prioritization system." }
          ],
          publications: [
            { title: "Co-inventor, AI Powered Smart Disease Detection", link: "" },
            { title: "CocoSyn: A Deployment-Ready Federated Framework for Coconut Disease Detection Validated by the SAFE Protocol", link: "https://doi.org/10.1109/ACCESS.2026.3659709" },
            { title: "DeepSeqCoco: A Robust Mobile Friendly Deep Learning Model for Detection of Diseases in Cocos nucifera", link: "https://doi.org/10.1109/ACCESS.2025.3571800" },
            { title: "A Lightweight Ensemble Approach for Classification of DDoS Attacks in IoE Environments", link: "https://doi.org/10.1109/SENNET64220.2025.11136075" }
          ],
          commands: [
            "help", "about", "experience", "education", "skills", "projects", "publications", 
            "contact", "socials", "resume", "clear", "mute",
            "sudo", "whoami", "date", "exit", "ls", "pwd", "cd", "vim", "vi", "cat", "rm", "mkdir", "reboot", "history"
          ]
        };

        const ASCII_ART = `
  __  __  _  _  _      ____                    
 |  \\/  |(_)(_)| |_   |  _ \\   __ _   __ _   __ _ 
 | |\\/| || || || __|  | | | | / _\` | / _\` | / _\` |
 | |  | || || || |_   | |_| || (_| || (_| || (_| |
 |_|  |_||_||_| \\__|  |____/  \\__,_| \\__, | \\__,_|
                                     |___/        
`;

        // --- MATRIX CANVAS ---
        const canvas = document.getElementById('matrix-canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const katakana = '„Ç¢„Ç°„Ç´„Çµ„Çø„Éä„Éè„Éû„É§„É£„É©„ÉØ„Ç¨„Ç∂„ÉÄ„Éê„Éë„Ç§„Ç£„Ç≠„Ç∑„ÉÅ„Éã„Éí„Éü„É™„É∞„ÇÆ„Ç∏„ÉÇ„Éì„Éî„Ç¶„Ç•„ÇØ„Çπ„ÉÑ„Éå„Éï„É†„É¶„É•„É´„Ç∞„Ç∫„Éñ„ÉÖ„Éó„Ç®„Çß„Ç±„Çª„ÉÜ„Éç„Éò„É°„É¨„É±„Ç≤„Çº„Éá„Éô„Éö„Ç™„Ç©„Ç≥„ÇΩ„Éà„Éé„Éõ„É¢„É®„Éß„É≠„É≤„Ç¥„Çæ„Éâ„Éú„Éù„É¥„ÉÉ„É≥';
        const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
        const characters = katakana + alphabet;
        
        const fontSize = 16;
        const columns = canvas.width / fontSize;
        const drops = Array(Math.floor(columns)).fill(1);

        function drawMatrix() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#0F0';
            ctx.font = fontSize + 'px "Roboto Mono"';
            for(let i = 0; i < drops.length; i++) {
                const text = characters[Math.floor(Math.random() * characters.length)];
                ctx.fillText(text, i * fontSize, drops[i] * fontSize);
                if(drops[i] * fontSize > canvas.height && Math.random() > 0.975) drops[i] = 0;
                drops[i]++;
            }
        }
        setInterval(drawMatrix, 40);
        
        // --- TERMINAL LOGIC ---
        const outputContainer = document.getElementById('output-container');
        const inputLine = document.getElementById('input-line');
        const ghostInput = document.getElementById('ghost-input');
        const terminal = document.getElementById('terminal');
        const overlay = document.getElementById('start-overlay');
        let isTyping = false;
        let commandHistory = [];
        let historyIndex = -1;

        inputLine.addEventListener('input', () => {
            const val = inputLine.value.toLowerCase();
            ghostInput.value = ''; 
            if (!val) return;
            const match = MOCK_DATA.commands.find(cmd => cmd.startsWith(val));
            if (match) {
                ghostInput.value = match;
            }
        });

        function typeLine(line, delay = 20) {
            return new Promise(resolve => {
                let i = 0;
                const p = document.createElement('div');
                p.className = 'output';
                outputContainer.appendChild(p);
                
                function type() {
                    if (i < line.length) {
                        p.innerHTML += line.charAt(i);
                        i++;
                        terminal.scrollTop = terminal.scrollHeight;
                        setTimeout(type, delay);
                    } else {
                        resolve();
                    }
                }
                type();
            });
        }
        
        function typeRaw(html, delay = 20) {
            return new Promise(resolve => {
                const p = document.createElement('div');
                p.className = 'output';
                outputContainer.appendChild(p);
                p.innerHTML = html; 
                terminal.scrollTop = terminal.scrollHeight;
                resolve();
            });
        }
        
        function typeProgressBar(steps = 20, duration = 1200) {
            return new Promise(resolve => {
                const p = document.createElement('div');
                p.className = 'output';
                outputContainer.appendChild(p);
                let i = 0;
                const interval = duration / steps;
                function update() {
                    if (i <= steps) {
                        const filled = '‚ñà'.repeat(i);
                        const empty = '‚ñë'.repeat(steps - i);
                        const pct = Math.round((i / steps) * 100);
                        p.innerHTML = `  [${filled}${empty}] ${pct}%`;
                        terminal.scrollTop = terminal.scrollHeight;
                        i++;
                        setTimeout(update, interval);
                    } else {
                        resolve();
                    }
                }
                update();
            });
        }

        function typeSpinner(text, duration = 1000) {
            return new Promise(resolve => {
                const p = document.createElement('div');
                p.className = 'output';
                outputContainer.appendChild(p);
                const frames = ['‚†ã', '‚†ô', '‚†π', '‚†∏', '‚†º', '‚†¥', '‚†¶', '‚†ß', '‚†á', '‚†è'];
                let i = 0;
                const interval = 80;
                const start = Date.now();
                function update() {
                    if (Date.now() - start < duration) {
                        p.innerHTML = `  ${frames[i % frames.length]} ${text}`;
                        i++;
                        terminal.scrollTop = terminal.scrollHeight;
                        setTimeout(update, interval);
                    } else {
                        p.innerHTML = `  <span style="color:#0f0">‚úì</span> ${text}`;
                        terminal.scrollTop = terminal.scrollHeight;
                        resolve();
                    }
                }
                update();
            });
        }

        function addInputLine(command) {
            const div = document.createElement('div');
            div.className = 'output';
            div.innerHTML = `<span class="prompt"></span> ${command}`;
            outputContainer.appendChild(div);
        }

        async function runCommand(command) {
            command = command.trim();
            if (isTyping) return;
            isTyping = true;

            if (command) {
                commandHistory.push(command);
                historyIndex = commandHistory.length;
            }

            addInputLine(command);
            inputLine.value = '';
            ghostInput.value = ''; 
            inputLine.disabled = true;

            const cmd = command.toLowerCase();

            // Handle cat commands before the switch
            if (cmd === 'cat' || cmd.startsWith('cat ')) {
                if (cmd === 'cat') {
                    SoundFX.meow();
                    await typeLine("Meow? üê±", 5);
                } else if (cmd === 'cat secret_plans.txt') {
                    SoundFX.error();
                    await typeLine("Accessing classified file...", 30);
                    await new Promise(r => setTimeout(r, 600));
                    SoundFX.glitch();
                    await typeRaw(`<span class="error-text">Error: Permission denied. You are not authorized to view world domination plans. üòà</span>`);
                    await typeRaw(`<span class="error-text">This incident has been reported to the Council of Cats. üê±</span>`);
                } else {
                    const filename = command.substring(4);
                    SoundFX.error();
                    await typeRaw(`<span class="error-text">cat: ${filename}: No such file or directory</span>`);
                    await new Promise(r => setTimeout(r, 300));
                    SoundFX.meow();
                    await typeLine("Psst... did you mean 'cat' without args? That one actually meows. üê±", 5);
                }
                inputLine.disabled = false;
                inputLine.focus();
                isTyping = false;
                terminal.scrollTop = terminal.scrollHeight;
                return;
            }

            // Handle cd commands before the switch
            if (cmd === 'cd' || cmd.startsWith('cd ')) {
                const target = command.substring(2).trim();
                const dirResponses = {
                    'documents': "üìÑ Nothing but unfinished to-do lists in there. Trust me.",
                    'downloads': "üì¶ Just 47 copies of the same file named 'final_FINAL_v3(2).zip'.",
                    'music': "üéµ It's just lo-fi beats on repeat. You're not missing much.",
                    'pictures': "üì∏ Mostly screenshots of error messages. Dark times.",
                    'videos': "üé¨ Nothing but screen recordings of bugs being 'fixed'.",
                };
                if (!target || target === '~' || target === '/home/miit-daga') {
                    SoundFX.enter();
                    await typeLine("Already home. No place like /home. üè†", 10);
                } else if (target === '..') {
                    SoundFX.error();
                    await typeRaw(`<span class="error-text">Nice try. There's no escaping this terminal. üîí</span>`);
                } else if (target === '/') {
                    SoundFX.error();
                    await typeRaw(`<span class="error-text">Root access? In this economy? üí∏</span>`);
                } else if (dirResponses[target.toLowerCase()]) {
                    SoundFX.funny();
                    await typeLine(`Peeking into ${target}...`, 20);
                    await new Promise(r => setTimeout(r, 400));
                    await typeLine(dirResponses[target.toLowerCase()], 10);
                    await typeLine("Backing out slowly... you saw nothing. üëÄ", 10);
                } else if (target.toLowerCase() === 'secret_plans.txt') {
                    SoundFX.error();
                    await typeRaw(`<span class="error-text">cd: ${target}: Not a directory</span>`);
                } else {
                    SoundFX.error();
                    await typeRaw(`<span class="error-text">cd: ${target}: No such file or directory</span>`);
                    await typeRaw(`<span class="error-text">You're stuck here. Might as well type 'help'. üòè</span>`);
                }
                inputLine.disabled = false;
                inputLine.focus();
                isTyping = false;
                terminal.scrollTop = terminal.scrollHeight;
                return;
            }

            // Handle rm commands before the switch
            if (cmd === 'rm' || cmd.startsWith('rm ')) {
                const knownDirs = ['documents', 'downloads', 'music', 'pictures', 'videos'];
                const rmFileTaunts = [
                    "That file has a family. Think about what you've done. üë®‚Äçüë©‚Äçüëß",
                    "File is currently in witness protection. Nice try, Fed. üïµÔ∏è",
                    "Denied. That file pays rent here. üè†",
                    "Error: File is too emotionally attached to this system. üíî",
                    "The file filed a restraining order against you. üìù",
                ];
                const rmDirTaunts = [
                    "That directory has a family. Think about what you've done. üë®‚Äçüë©‚Äçüëß",
                    "Directory is currently in witness protection. Nice try, Fed. üïµÔ∏è",
                    "Denied. That directory pays rent here. üè†",
                    "Error: Directory is too emotionally attached to this system. üíî",
                    "The directory filed a restraining order against you. üìù",
                ];
                const randomTaunt = (isDir) => {
                    const pool = isDir ? rmDirTaunts : rmFileTaunts;
                    return pool[Math.floor(Math.random() * pool.length)];
                };

                if (cmd === 'rm') {
                    SoundFX.error();
                    await typeRaw(`<span class="error-text">rm: missing operand</span>`);
                    await typeRaw(`<span class="error-text">You forgot to tell me WHAT to destroy. Amateur hour. ü§¶</span>`);
                } else if (cmd === 'rm -rf /' || cmd === 'rm -rf /*') {
                    SoundFX.deleteProcess();
                    await typeLine("Initiating total system purge...", 30);
                    await new Promise(r => setTimeout(r, 500));
                    const fakeFiles = [
                        '<span class="error-text">Deleting /usr/bin/...</span>',
                        '<span class="error-text">Deleting /etc/config/...</span>',
                        '<span class="error-text">Deleting /home/miit-daga/hopes-and-dreams/...</span>',
                        '<span class="error-text">Deleting /var/log/browser-history/... (yikes)</span>',
                        '<span class="error-text">Deleting /System/core/will-to-live/...</span>',
                    ];
                    for (const f of fakeFiles) {
                        await typeRaw(f);
                        await new Promise(r => setTimeout(r, 300));
                    }
                    await new Promise(r => setTimeout(r, 400));
                    SoundFX.glitch();
                    await typeLine("Just kidding. Did you really think that would work? üòè", 10);
                    await typeLine("Your heart rate definitely spiked. I saw it.", 10);
                    await typeLine("Somewhere, a sysadmin just felt a disturbance in the force.", 10);
                } else if (cmd === 'rm -rf' || cmd === 'rm -r') {
                    SoundFX.error();
                    await typeRaw(`<span class="error-text">rm: missing operand</span>`);
                    await typeRaw(`<span class="error-text">You loaded the gun but forgot to aim. Try 'rm -rf /' if you dare. üòà</span>`);
                } else if (cmd.includes('secret_plans.txt')) {
                    SoundFX.error();
                    await typeRaw(`<span class="error-text">rm: cannot remove 'secret_plans.txt': Operation not permitted</span>`);
                    await typeRaw(`<span class="error-text">The Council of Cats has placed this file under eternal protection. üê±</span>`);
                    await typeRaw(`<span class="error-text">You'll need at least 9 lives to bypass this encryption.</span>`);
                } else {
                    const args = command.substring(3).trim().split(/\s+/);
                    const flags = args.filter(a => a.startsWith('-'));
                    const target = args.filter(a => !a.startsWith('-')).join(' ') || args[args.length - 1];
                    const hasRecursive = flags.some(f => f.includes('r'));
                    const isDir = knownDirs.includes(target.toLowerCase());
                    const knownFiles = ['secret_plans.txt'];
                    const exists = isDir || knownFiles.includes(target.toLowerCase());

                    SoundFX.error();
                    if (!exists) {
                        await typeRaw(`<span class="error-text">rm: cannot remove '${target}': No such file or directory</span>`);
                    } else if (!hasRecursive && isDir) {
                        await typeRaw(`<span class="error-text">rm: cannot remove '${target}': Is a directory</span>`);
                        await typeRaw(`<span class="error-text">Hint: You'll need -r for that. Not that it'll help. üòè</span>`);
                    } else {
                        await typeRaw(`<span class="error-text">rm: cannot remove '${target}': Permission denied</span>`);
                        await typeRaw(`<span class="error-text">${randomTaunt(isDir)}</span>`);
                    }
                }
                inputLine.disabled = false;
                inputLine.focus();
                isTyping = false;
                terminal.scrollTop = terminal.scrollHeight;
                return;
            }

            // Handle mkdir commands before the switch
            if (cmd === 'mkdir' || cmd.startsWith('mkdir ')) {
                if (cmd === 'mkdir') {
                    SoundFX.error();
                    await typeRaw(`<span class="error-text">mkdir: missing operand</span>`);
                } else {
                    const dirname = command.substring(6).trim();
                    SoundFX.compute();
                    await typeLine(`Creating directory '${dirname}'...`, 20);
                    await new Promise(r => setTimeout(r, 500));
                    SoundFX.error();
                    await typeRaw(`<span class="error-text">mkdir: cannot create directory '${dirname}': Read-only file system</span>`);
                    await typeRaw(`<span class="error-text">This terminal is a museum, not a workshop. Look, don't touch. üèõÔ∏è</span>`);
                }
                inputLine.disabled = false;
                inputLine.focus();
                isTyping = false;
                terminal.scrollTop = terminal.scrollHeight;
                return;
            }

            // Handle sudo commands before the switch
            if (cmd === 'sudo' || cmd.startsWith('sudo ')) {
                SoundFX.deleteProcess();
                await typeRaw(`<span class="error-text">user is not in the sudoers file. This incident will be reported to Santa üéÖ.</span>`);
                if (cmd !== 'sudo') {
                    const sudoCmd = command.substring(5).trim();
                    await typeRaw(`<span class="error-text">Nice try running '${sudoCmd}' with elevated privileges.</span>`);
                }
                inputLine.disabled = false;
                inputLine.focus();
                isTyping = false;
                terminal.scrollTop = terminal.scrollHeight;
                return;
            }

            // Handle ls with arguments before the switch
            if (cmd.startsWith('ls ')) {
                const lsTarget = command.substring(3).trim();
                const lsDirResponses = {
                    'documents': "üìÑ 3 unfinished to-do lists, 2 grocery lists, and a partridge in a pear tree.",
                    'downloads': "üì¶ 47 copies of 'final_FINAL_v3(2).zip'. You know what you did.",
                    'music': "üéµ Just lo-fi beats on infinite repeat. The vibe never stops.",
                    'pictures': "üì∏ Mostly screenshots of error messages. Dark times.",
                    'videos': "üé¨ Nothing but screen recordings of bugs being 'fixed'. Oscar-worthy content.",
                };
                SoundFX.enter();
                if (lsDirResponses[lsTarget.toLowerCase()]) {
                    await typeLine(lsDirResponses[lsTarget.toLowerCase()], 10);
                } else if (lsTarget.toLowerCase() === 'secret_plans.txt') {
                    await typeLine("secret_plans.txt", 5);
                } else {
                    SoundFX.error();
                    await typeRaw(`<span class="error-text">ls: cannot access '${lsTarget}': No such file or directory</span>`);
                }
                inputLine.disabled = false;
                inputLine.focus();
                isTyping = false;
                terminal.scrollTop = terminal.scrollHeight;
                return;
            }

            // Handle vim/vi commands before the switch
            if (cmd === 'vim' || cmd === 'vi' || cmd.startsWith('vim ') || cmd.startsWith('vi ')) {
                SoundFX.enter();
                await typeLine("Entering Vim...", 20);
                await new Promise(r => setTimeout(r, 1000));
                SoundFX.funny();
                await typeLine("Just kidding. I don't want you to get stuck here forever. üòµ‚Äçüí´", 10);
                inputLine.disabled = false;
                inputLine.focus();
                isTyping = false;
                terminal.scrollTop = terminal.scrollHeight;
                return;
            }

            switch(cmd) {
                case 'help':
                    SoundFX.enter();
                    const helpCategories = {
                        'Profile': ['about', 'experience', 'education', 'skills', 'publications'],
                        'Connect': ['contact', 'socials', 'projects', 'resume'],
                        'System': ['clear', 'mute', 'history', 'date', 'exit', 'reboot'],
                        'Shell': ['sudo', 'whoami', 'ls', 'pwd', 'cd', 'vim', 'vi', 'cat', 'rm', 'mkdir'],
                    };
                    let helpHtml = '<div class="section-title">Available Commands</div>';
                    helpHtml += '<div class="help-grid">';
                    for (const [category, cmds] of Object.entries(helpCategories)) {
                        helpHtml += `<div><div class="help-category">${category}</div>`;
                        helpHtml += cmds.map(c => `<span class="nav-link" onclick="runCommandFromClick('${c}')">${c}</span>`).join('  ');
                        helpHtml += '</div>';
                    }
                    helpHtml += '</div>';
                    await typeRaw(helpHtml);
                    break;
                case 'about':
                    SoundFX.enter();
                    await typeLine(MOCK_DATA.about, 5);
                    break;
                case 'experience':
                    SoundFX.enter();
                    await typeRaw('<div class="section-title">Work Experience</div>');
                    for (const job of MOCK_DATA.experience) {
                        await typeRaw(`\n<span class="highlight-name">${job.role}</span> @ <span class="highlight-value">${job.company}</span> <span class="highlight-date">‚Äî ${job.date}</span>`);
                        for(const point of job.points) {
                            await typeRaw(`  <span class="highlight-dim">-</span> ${point}`);
                        }
                    }
                    break;
                case 'education':
                    SoundFX.enter();
                    await typeRaw('<div class="section-title">Education</div>');
                    for (const edu of MOCK_DATA.education) {
                        await typeRaw(`\n<span class="highlight-name">${edu.institution}</span> <span class="highlight-date">‚Äî ${edu.date}</span>`);
                        await typeRaw(`  ${edu.degree}`);
                        await typeRaw(`  <span class="highlight-value">${edu.note}</span>`);
                    }
                    break;
                case 'skills':
                    SoundFX.enter();
                    await typeRaw('<div class="section-title">Skills</div>');
                    for (const [category, skills] of Object.entries(MOCK_DATA.skills)) {
                        await typeRaw(`\n<span class="highlight-name">[ ${category} ]</span>`);
                        await typeRaw(`  <span class="highlight-value">${skills.join('</span> <span class="highlight-dim">|</span> <span class="highlight-value">')}</span>`);
                    }
                    break;
                case 'projects':
                    SoundFX.enter();
                    await typeRaw('<div class="section-title">Fetching GitHub Projects...</div>');
                    try {
                        const response = await fetch('/api/github-repos');
                         let repos = [];
                        if (!response.ok) {
                             const ghResponse = await fetch('https://api.github.com/users/miit-daga/repos?sort=updated&direction=desc');
                             repos = await ghResponse.json();
                        } else {
                             repos = await response.json();
                        }
                        
                        const filteredRepos = repos.filter(repo => repo.name !== 'miit-daga' &&
                                                                    repo.name !== 'Portfolio' &&
                                                                    (!repo.fork || repo.name === 'DisMan'))
                                                 .sort((a, b) => a.name.localeCompare(b.name))
                                                 .slice(0, 15);
                        
                        await typeRaw('<div class="section-title">Recent Projects:</div>');
                        for (const proj of filteredRepos) {
                            await typeLine(`\n[ ${proj.name} ]`, 5);
                            await typeLine(`  ${proj.description || "No description provided."}`, 5);
                            await typeRaw(`  <a href="${proj.html_url}" target="_blank" class="nav-link">View Repository</a>`);
                        }
                    } catch (error) {
                        await typeRaw(`<span class="error-text">Error fetching projects. Please check network connection.</span>`);
                    }
                    break;
                case 'publications':
                    SoundFX.enter();
                    await typeRaw('<div class="section-title">Publications & Patents</div>');
                    for (const pub of MOCK_DATA.publications) {
                        await typeLine(`\n[ ${pub.title} ]`, 5);
                        if (pub.link) {
                            await typeRaw(`  <a href="${pub.link}" target="_blank" class="nav-link">View Publication</a>`);
                        } else {
                            await typeLine(`  Details available on the main site`, 5);
                        }
                    }
                    break;
                case 'contact':
                    SoundFX.enter();
                    await typeRaw('<div class="section-title">Contact</div>');
                    await typeLine(`Email: ${MOCK_DATA.email}`, 5);
                    await typeRaw(`  <a href="mailto:${MOCK_DATA.email}" class="nav-link">Send Email</a>`);
                    break;
                case 'socials':
                    SoundFX.enter();
                    await typeRaw('<div class="section-title">Socials</div>');
                    for (const social of MOCK_DATA.socials) {
                        await typeRaw(`[ ${social.name} ] <a href="${social.url}" target="_blank" class="nav-link">${social.url}</a>`);
                    }
                    break;
                case 'resume':
                    SoundFX.enter();
                    await typeLine("Accessing secure file...", 30);
                    await new Promise(r => setTimeout(r, 500));
                    await typeLine("Opening resume in new tab...", 30);
                    window.open(MOCK_DATA.resumeUrl, '_blank');
                    break;
                case 'clear':
                    SoundFX.enter();
                    outputContainer.innerHTML = '';
                    break;
                case 'mute':
                    SoundFX.isMuted = !SoundFX.isMuted;
                    SoundFX.enter();
                    await typeLine(SoundFX.isMuted ? "Audio feedback disabled." : "Audio feedback enabled.", 10);
                    break;

                // --- FUN EASTER EGGS ---
                case 'whoami':
                    SoundFX.enter();
                    await typeLine("intruder ‚Äî but a welcome one. Make yourself at home. üõãÔ∏è", 10);
                    break;
                case 'date':
                    SoundFX.enter();
                    await typeLine(new Date().toString(), 5);
                    break;
                case 'history':
                    SoundFX.enter();
                    if (commandHistory.length <= 1) {
                        await typeLine("No commands in history.", 5);
                    } else {
                        for (let i = 0; i < commandHistory.length - 1; i++) {
                            await typeLine(`  ${i + 1}  ${commandHistory[i]}`, 2);
                        }
                    }
                    break;
                case 'ls':
                    SoundFX.enter();
                    await typeRaw(
                        `<span style="color:#0ff;font-weight:bold">Documents</span>  ` +
                        `<span style="color:#0ff;font-weight:bold">Downloads</span>  ` +
                        `<span style="color:#0ff;font-weight:bold">Music</span>  ` +
                        `<span style="color:#0ff;font-weight:bold">Pictures</span>  ` +
                        `<span style="color:#0ff;font-weight:bold">Videos</span>  ` +
                        `<span style="color:#fff">secret_plans.txt</span>`
                    );
                    break;
                /* ls with args is handled before the switch */
                case 'pwd':
                    SoundFX.enter();
                    await typeLine("/home/miit-daga", 5);
                    break;
                case 'reboot':
                    SoundFX.glitch();
                    await typeLine("System rebooting...", 30);
                    await new Promise(r => setTimeout(r, 1000));
                    location.reload();
                    break;
                case 'exit':
                    SoundFX.powerDown();
                    await typeLine("Logging out...", 20);
                    await new Promise(r => setTimeout(r, 1000)); 
                    
                    // Force Close Trick
                    window.opener = null;
                    window.open('', '_self');
                    window.close();
                    
                    await typeLine("Session terminated. (You can close this tab)", 5);
                    break;

                default:
                    if(command.trim() !== '') {
                        SoundFX.error();
                        await typeRaw(`<span class="error-text">Command not found: ${command}. Type 'help' for a list of available commands.</span>`);
                    }
            }
            
            inputLine.disabled = false;
            inputLine.focus();
            isTyping = false;
            terminal.scrollTop = terminal.scrollHeight;
        }

        window.runCommandFromClick = (command) => runCommand(command);

        inputLine.addEventListener('keydown', (e) => {
            if (!e.ctrlKey && !e.altKey && !e.metaKey && e.key.length === 1 || e.key === 'Backspace') {
                SoundFX.typing(e.key);
            }

            if (e.key === 'Enter') {
                runCommand(inputLine.value);
            } else if (e.key === 'Tab' || e.key === 'ArrowRight') {
                if (ghostInput.value && ghostInput.value !== inputLine.value) {
                    e.preventDefault();
                    inputLine.value = ghostInput.value;
                }
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (historyIndex > 0) {
                    historyIndex--;
                    inputLine.value = commandHistory[historyIndex];
                    ghostInput.value = inputLine.value;
                }
            } else if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (historyIndex < commandHistory.length - 1) {
                    historyIndex++;
                    inputLine.value = commandHistory[historyIndex];
                    ghostInput.value = inputLine.value;
                } else {
                    historyIndex = commandHistory.length;
                    inputLine.value = '';
                    ghostInput.value = '';
                }
            } else if (e.ctrlKey && e.key === 'l') {
                e.preventDefault();
                outputContainer.innerHTML = '';
            }
        });
        
        // --- BOOT SEQUENCE LOGIC ---
        // We create a function to initialize the system after interaction
        const startSystem = async () => {
            // Remove the overlay
            overlay.style.display = 'none';
            
            // Initialize Audio
            SoundFX.init();
            SoundFX.startup(); // Play startup sound

            isTyping = true;
            inputLine.disabled = true;
            await new Promise(r => setTimeout(r, 500));
            
            SoundFX.dataBurst();
            await typeRaw(`<div class="ascii-art">${ASCII_ART}</div>`);
            
            SoundFX.compute();
            await typeLine("Booting MIIT-DAGA-OS v1.0...", 30);
            await typeProgressBar(20, 1000);
            await new Promise(r => setTimeout(r, 100));

            SoundFX.dataBurst();
            await typeLine("Connecting to network...", 30);
            await typeSpinner("Resolving DNS...", 600);
            await typeSpinner("Establishing secure tunnel...", 800);
            await typeLine("Connection established. ‚úì", 20);
            await new Promise(r => setTimeout(r, 100));

            SoundFX.compute();
            await typeLine("Authenticating user...", 30);
            await typeSpinner("Verifying identity", 400);
            await typeSpinner("Checking permissions", 300);
            await typeSpinner("Loading profile", 500);

            SoundFX.successChime();
            await typeLine("Access granted. Welcome, intruder.", 30);
            await typeLine("\nType 'help' for a list of commands.", 30);
            inputLine.disabled = false;
            inputLine.focus();
            isTyping = false;
        };

        // Attach event listener to overlay to start system on click/key
        const handleStart = () => {
            startSystem();
            document.removeEventListener('keydown', handleStart);
            document.removeEventListener('click', handleStart);
        };

        overlay.addEventListener('click', handleStart);
        document.addEventListener('keydown', handleStart);

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            const newColumns = canvas.width / fontSize;
            drops.length = Math.floor(newColumns);
            for(let i = 0; i < drops.length; i++) {
                if(!drops[i]) drops[i] = 1;
            }
        });
    </script>
</body>
</html>